HEAD指向提交, 分支指针是分支树的一个叶节点,指向"它认为的"最末节点,通常HEAD指向提交是通过和分支指针相等来实现的.但部分 时候HEAD也可以灵活的单独变换,称之为分离状态.
`git reset <HashValueOfCommit>`会把HEAD指针和当前所属的分支指针一同移动到某个提交处, 显然移动前的提交在移动后有所有分支指针(包括当前所属分支指针在内)都访问不到的风险,这时这些东西就成为了悬空分支,也就是无法通过分支指针访问到的东西.悬空分支并不会被直接删除,仍然可以通过`git reflog`命令查看HEAD位置的历史记录从而查询到分支哈希值,在跳转过去,但显然这很不正规,实际上也确实如此,此时这个提交就会被归类为垃圾,会在git仓库体积逐渐膨胀的过程中激活垃圾清理机制,届时可能会被清除掉,所以请确保有用的分支不属于悬空分支

`git reset --soft <commit>`可以把HEAD和当前所用分支指针一起更改为指向commit, 同时--soft模式不会额外做其他事情,--mixed模式(也是默认模式)会同时清空暂存区,--hard模式会清空暂存区并把工作区内容切换为新分支的内容

`git checkout <commit>`只会移动HEAD, 不会移动当前所属分支指针, 同时对工作区和暂存区的行为类似于reset的hard模式,然而,reset面对可能把工作区或者暂存区未保存的更改覆盖掉的风险时不会警告,而是会直接强行执行,那么这部分内容就相当于永久丢失了,而checkout在面对风险的时候会给出警告,提示我们进行merge等操作.整体而言我们显然不希望回到过去的过程中把分支指针拖走,也不希望过于危险的reset hard模式和mixed模式造成永久丢失,因此一般来书使用checkout即可.

以上两个命令无论是否移动当前分支指针,都不会改变那个分支指针属于当前所属分支指针这一点, 实际上这个所属,可以理解为有一个最高级指针,名称是当前分支高级指针(自己编的,为了和之前的指针做出区别),该指针指向了某个分支指针,这个被指向的指针就是当前分支指针. 而`git switch <NameOfBrach>`提供了切换这个高级指针的可能性,直接就可以吧高级指针指向写出的分支名.

`git restore`则是单纯的清空暂存区或者用某个版本的文件覆盖工作区的部分或全部文件,也就是单纯执行checkout/reset的后半部分功能,并不会改变HEAD和分支指针

`git branch`则可以列出当前所有分支(并用\*标注当前所在分支,\*可以理解我我前面说的那个高级指针的具象表示)
`git branch <NameOfBranch>`可以创建新的分支指针,指向当前提交,也就是使之等于HEAD
`git branch -m <oldName> <newName>`可以重命名分支
`git branch -f <分支名> <目标提交>`可以单纯移动分支指针,而不改变其他内容
`git branch -d <feature-branch>`会删除已经合并到当前分支上的feature-branch的分支指针,如果并非已经合并(也就是当前指针向前追溯无法访问到feature-branch),那么就会弹出警告.将-d切换成-D可以无视警告强行删除,那么该指令就变成了简单的删除分支指令,当然会有风险,那就是可能造成悬空分支

重新来, switch提供了对高级指针的操作,从而指定当前分支指针,并同时把HEAD移动到当前分支指针处. branch提供了对当前分支指针的操作,可以创建删除或移动分支指针.
restore可以应用特定提交的内容,而不改变指针.checkout会"起到restore功能也就是应用提交内容"的同时改变HEAD指针但不改变当前分支指针.而reset会"起到restore功能也就是应用提交内容"的同时移动HEAD指针和当前分支指针,相当于
```
switchBranch = 高级指针移动 + HEAD移动
checkoutCommit = 'restore' + HEAD移动
resetCommit = 'checkoutCommit' + 'branch-f' - 警告信息
实际上还有switchCommit = checkoutCommit...
```

接下来就是重头戏了,合并Merge,先来谈两者的merge,也就是把某某分支与当前分支进行合并的这一操作
如果两个分支中,一者是另一者的直接下游,那么直接简单的把当前分支指针移动到两者中较新分支指针处即可,被合并的分支则不会移动,并不会产生合并提交,称之为快速合并(Fast-forward) .但也可以通过添加--no-ff参数来强行生成一个不产生任何更改的提交来作为合并提交,好处是可以保留合并记录
如果并非如此,那么就会先找到另个分支的共同祖先提交, 然后把两个分支的分支指针所指向处的全部更改分析出来,然后把更改合并起来,由共同祖先和合并更改生成最终合并版本并提交,由此产生一个新的提交,称之为合并提交,两个分支指针都会移动到这个新的合并提交处
显然多者merge就会多次调用两者merge,不再赘述
这里说一下如何产生合并提交,如果两者对同一文件的不同部分或者对不同文件做了修改,或者对同一文件同一部分做了同样的修改,那么把更改直接叠加即可.如果对同一文件的同一部分进行了不同修改,那么就会产生合并冲突,git暂时并不会生成合并提交,而是会标记处冲突的部分让程序员手动解决冲突,解决后才会生成合并提交.
具体而言,冲突发生时会弹出冲突提示,此时程序员可以通过git status可以查看哪些文件存在冲突,然后打开工作区的对应文件就可以看到Git标记出的冲突处,把冲突内容修改好了之后直接把这个文件的程序员希望看到的最终版本用git add指令放到暂存区中然后commit即可,此时如果所有冲突文件都在暂存区中,那么这个commit指令就会让暂存区和非冲突内容共同生成一个合并提交,并把当前分支指针移动到合并提交处,被合并的分支指针不会移动