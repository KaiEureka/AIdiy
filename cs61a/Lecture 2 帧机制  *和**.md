#cs61a  #python语法

python在使用一个变量的时候才会动态的确定他是什么类型的，因此只要使用的时候不发生错误，那么代码就可以运行，因此诸如
```python
def square(square) :
	return square * square
print(square(-2))
```
是可以正确的输出4的，因为先别管没调用print(square(-2))的时候的def过程做了什么，函数本身只是一串待解释的语句，没有带入具体值的时候就不必分析它的语义是否合理，这与cpp等编译型语言的必须定义的时候就语义合理否则直接报错完全不同，只有调用了我们才来分析他干了什么，而且只要干的不非法（比如把int当做func调用才算非法）那就可以运行。

所以直接看square(-2)，这是一条顶级语句，因此直接在顶级域(也就是全局帧Global frame)中搜索，发现有一个函数叫做square，所以没问题，直接把-2作为参数调用square，然后才开始解释器分析def过程，解释器发现参数名为square，解释器表示没问题square现在是一个参数了并且初始化为代入的数值-2，并且这个局部参数已经成为square在当前作用范围内（py称之为帧frame）的优先代指对象，然后第三第四个square自然是调用了局部变量。发生的是```int*int```自然没有问题.

另外，py所有函数，没有返回值就默认返回None，print函数的返回值就是None

py中定义函数是如果以```*a```作为唯一参数，那么调用时可以给出任意多个参数，他们会把所有这些参数整合成一个元组（写作tuple，是定长vector，类似matlab的元胞数组），然后这个tuple的名字是a，你就可以调用了。在这里，显然```*```是一个把list变成他的所有元素的这样一个“解包”的过程，在函数参数中写入```*a```显然是一个反解包的过程，表示让a等于以所有输入元素为子元素的list。py中没有指针的概念，```*```表示解包。py中的tuple（小括号，cppArray），list（中括号，cppVector），set（大括号，cppSet）是一个类似元胞数组的东西，可以把任何东西打包起来，不需要同类型，```*```则是解包，放到形参位置则是和cpp一样表示反向使用，那此时就是打包过程。

值得注意的是，字典dict（大括号+内部冒号，cppMap，形如```my_dict = {'a': 1, 'b': 2, 'c': 3}```）,解包为所有的key则是用单引号,解包为所有的value只需要需要两个星号，也即形如```**```,比如
```python
def func(a, b, c):
	print(a, b, c)
my_dict = {'a': 1, 'b': 2, 'c': 3}
func(*my_dict) # 输出 a b c
func(**my_dict)# 输出 1 2 3
print(my_dict) # 输出 {'a': 1, 'b': 2, 'c': 3}
```
py中没有指针,但py中有引用的概念，两个int的赋值调用的是真的赋值，但两个object的赋值经常实际上是把一个视为另一个的引用，如果想要真的赋值则需要调用copy等类方法